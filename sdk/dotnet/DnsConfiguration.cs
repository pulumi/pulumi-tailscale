// *** WARNING: this file was generated by pulumi-language-dotnet. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Tailscale
{
    /// <summary>
    /// The DnsConfiguration resource allows you to manage the complete DNS configuration for your Tailscale network. See https://tailscale.com/kb/1054/dns for more information.
    /// 
    /// &gt; **Note:** The Tailscale Terraform provider has multiple resources for managing DNS configuration. This resource is meant to manage the entirety of a Tailnet's DNS configuration and conflicts with tailscale_dns_nameservers, tailscale_dns_preferences, tailscale_dns_search_paths, and tailscale_dns_split_nameservers. This resource and previously mentioned resources should not be used simultaneously.
    /// 
    /// ## Example Usage
    /// 
    /// ```csharp
    /// using System.Collections.Generic;
    /// using System.Linq;
    /// using Pulumi;
    /// using Tailscale = Pulumi.Tailscale;
    /// 
    /// return await Deployment.RunAsync(() =&gt; 
    /// {
    ///     var sampleConfiguration = new Tailscale.DnsConfiguration("sample_configuration", new()
    ///     {
    ///         Nameservers = new[]
    ///         {
    ///             new Tailscale.Inputs.DnsConfigurationNameserverArgs
    ///             {
    ///                 Address = "8.8.8.8",
    ///             },
    ///             new Tailscale.Inputs.DnsConfigurationNameserverArgs
    ///             {
    ///                 Address = "1.1.1.1",
    ///                 UseWithExitNode = true,
    ///             },
    ///         },
    ///         SplitDns = new[]
    ///         {
    ///             new Tailscale.Inputs.DnsConfigurationSplitDnArgs
    ///             {
    ///                 Domain = "foo.example.com",
    ///                 Nameservers = new[]
    ///                 {
    ///                     new Tailscale.Inputs.DnsConfigurationSplitDnNameserverArgs
    ///                     {
    ///                         Address = "1.1.1.2",
    ///                         UseWithExitNode = true,
    ///                     },
    ///                     new Tailscale.Inputs.DnsConfigurationSplitDnNameserverArgs
    ///                     {
    ///                         Address = "1.1.1.3",
    ///                     },
    ///                 },
    ///             },
    ///             new Tailscale.Inputs.DnsConfigurationSplitDnArgs
    ///             {
    ///                 Domain = "bar.example.com",
    ///                 Nameservers = new[]
    ///                 {
    ///                     new Tailscale.Inputs.DnsConfigurationSplitDnNameserverArgs
    ///                     {
    ///                         Address = "8.8.8.2",
    ///                         UseWithExitNode = true,
    ///                     },
    ///                 },
    ///             },
    ///         },
    ///         SearchPaths = new[]
    ///         {
    ///             "example.com",
    ///             "anotherexample.com",
    ///         },
    ///         OverrideLocalDns = true,
    ///         MagicDns = true,
    ///     });
    /// 
    /// });
    /// ```
    /// 
    /// ## Import
    /// 
    /// ID doesn't matter.
    /// 
    /// ```sh
    /// $ pulumi import tailscale:index/dnsConfiguration:DnsConfiguration sample_configuration dns_configuration
    /// ```
    /// </summary>
    [TailscaleResourceType("tailscale:index/dnsConfiguration:DnsConfiguration")]
    public partial class DnsConfiguration : global::Pulumi.CustomResource
    {
        /// <summary>
        /// Whether or not to enable MagicDNS. Defaults to true.
        /// </summary>
        [Output("magicDns")]
        public Output<bool?> MagicDns { get; private set; } = null!;

        /// <summary>
        /// Set the nameservers used by devices on your network to resolve DNS queries. `OverrideLocalDns` must also be true to prefer these nameservers over local DNS configuration.
        /// </summary>
        [Output("nameservers")]
        public Output<ImmutableArray<Outputs.DnsConfigurationNameserver>> Nameservers { get; private set; } = null!;

        /// <summary>
        /// When enabled, use the configured DNS servers in `Nameservers` to resolve names outside the tailnet. When disabled, devices will prefer their local DNS configuration. Defaults to false.
        /// </summary>
        [Output("overrideLocalDns")]
        public Output<bool?> OverrideLocalDns { get; private set; } = null!;

        /// <summary>
        /// Additional search domains. When MagicDNS is on, the tailnet domain is automatically included as the first search domain.
        /// </summary>
        [Output("searchPaths")]
        public Output<ImmutableArray<string>> SearchPaths { get; private set; } = null!;

        /// <summary>
        /// Set the nameservers used by devices on your network to resolve DNS queries on specific domains (requires Tailscale v1.8 or later). Configuration does not depend on `OverrideLocalDns`.
        /// </summary>
        [Output("splitDns")]
        public Output<ImmutableArray<Outputs.DnsConfigurationSplitDn>> SplitDns { get; private set; } = null!;


        /// <summary>
        /// Create a DnsConfiguration resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public DnsConfiguration(string name, DnsConfigurationArgs? args = null, CustomResourceOptions? options = null)
            : base("tailscale:index/dnsConfiguration:DnsConfiguration", name, args ?? new DnsConfigurationArgs(), MakeResourceOptions(options, ""))
        {
        }

        private DnsConfiguration(string name, Input<string> id, DnsConfigurationState? state = null, CustomResourceOptions? options = null)
            : base("tailscale:index/dnsConfiguration:DnsConfiguration", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing DnsConfiguration resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static DnsConfiguration Get(string name, Input<string> id, DnsConfigurationState? state = null, CustomResourceOptions? options = null)
        {
            return new DnsConfiguration(name, id, state, options);
        }
    }

    public sealed class DnsConfigurationArgs : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Whether or not to enable MagicDNS. Defaults to true.
        /// </summary>
        [Input("magicDns")]
        public Input<bool>? MagicDns { get; set; }

        [Input("nameservers")]
        private InputList<Inputs.DnsConfigurationNameserverArgs>? _nameservers;

        /// <summary>
        /// Set the nameservers used by devices on your network to resolve DNS queries. `OverrideLocalDns` must also be true to prefer these nameservers over local DNS configuration.
        /// </summary>
        public InputList<Inputs.DnsConfigurationNameserverArgs> Nameservers
        {
            get => _nameservers ?? (_nameservers = new InputList<Inputs.DnsConfigurationNameserverArgs>());
            set => _nameservers = value;
        }

        /// <summary>
        /// When enabled, use the configured DNS servers in `Nameservers` to resolve names outside the tailnet. When disabled, devices will prefer their local DNS configuration. Defaults to false.
        /// </summary>
        [Input("overrideLocalDns")]
        public Input<bool>? OverrideLocalDns { get; set; }

        [Input("searchPaths")]
        private InputList<string>? _searchPaths;

        /// <summary>
        /// Additional search domains. When MagicDNS is on, the tailnet domain is automatically included as the first search domain.
        /// </summary>
        public InputList<string> SearchPaths
        {
            get => _searchPaths ?? (_searchPaths = new InputList<string>());
            set => _searchPaths = value;
        }

        [Input("splitDns")]
        private InputList<Inputs.DnsConfigurationSplitDnArgs>? _splitDns;

        /// <summary>
        /// Set the nameservers used by devices on your network to resolve DNS queries on specific domains (requires Tailscale v1.8 or later). Configuration does not depend on `OverrideLocalDns`.
        /// </summary>
        public InputList<Inputs.DnsConfigurationSplitDnArgs> SplitDns
        {
            get => _splitDns ?? (_splitDns = new InputList<Inputs.DnsConfigurationSplitDnArgs>());
            set => _splitDns = value;
        }

        public DnsConfigurationArgs()
        {
        }
        public static new DnsConfigurationArgs Empty => new DnsConfigurationArgs();
    }

    public sealed class DnsConfigurationState : global::Pulumi.ResourceArgs
    {
        /// <summary>
        /// Whether or not to enable MagicDNS. Defaults to true.
        /// </summary>
        [Input("magicDns")]
        public Input<bool>? MagicDns { get; set; }

        [Input("nameservers")]
        private InputList<Inputs.DnsConfigurationNameserverGetArgs>? _nameservers;

        /// <summary>
        /// Set the nameservers used by devices on your network to resolve DNS queries. `OverrideLocalDns` must also be true to prefer these nameservers over local DNS configuration.
        /// </summary>
        public InputList<Inputs.DnsConfigurationNameserverGetArgs> Nameservers
        {
            get => _nameservers ?? (_nameservers = new InputList<Inputs.DnsConfigurationNameserverGetArgs>());
            set => _nameservers = value;
        }

        /// <summary>
        /// When enabled, use the configured DNS servers in `Nameservers` to resolve names outside the tailnet. When disabled, devices will prefer their local DNS configuration. Defaults to false.
        /// </summary>
        [Input("overrideLocalDns")]
        public Input<bool>? OverrideLocalDns { get; set; }

        [Input("searchPaths")]
        private InputList<string>? _searchPaths;

        /// <summary>
        /// Additional search domains. When MagicDNS is on, the tailnet domain is automatically included as the first search domain.
        /// </summary>
        public InputList<string> SearchPaths
        {
            get => _searchPaths ?? (_searchPaths = new InputList<string>());
            set => _searchPaths = value;
        }

        [Input("splitDns")]
        private InputList<Inputs.DnsConfigurationSplitDnGetArgs>? _splitDns;

        /// <summary>
        /// Set the nameservers used by devices on your network to resolve DNS queries on specific domains (requires Tailscale v1.8 or later). Configuration does not depend on `OverrideLocalDns`.
        /// </summary>
        public InputList<Inputs.DnsConfigurationSplitDnGetArgs> SplitDns
        {
            get => _splitDns ?? (_splitDns = new InputList<Inputs.DnsConfigurationSplitDnGetArgs>());
            set => _splitDns = value;
        }

        public DnsConfigurationState()
        {
        }
        public static new DnsConfigurationState Empty => new DnsConfigurationState();
    }
}
